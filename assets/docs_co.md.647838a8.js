import{_ as n,c as a,b as l,a as o,o as p,r as e}from"./chunks/framework.4e4e9037.js";const d=JSON.parse('{"title":"王小壮壮 |【学习篇】线程池","description":"","frontmatter":{"date":"2023-03-15T00:00:00.000Z","title":"王小壮壮 |【学习篇】线程池","tags":["学习记录"],"describe":"线程池"},"headers":[],"relativePath":"docs/co.md"}'),t={name:"docs/co.md"},c=o(`<blockquote><p>线程池</p></blockquote><h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h1><p>对线程池相关面试题的分析以及里面重要的源码的分析。</p><hr><h1 id="_1-线程池的基本状态" tabindex="-1">1.线程池的基本状态 <a class="header-anchor" href="#_1-线程池的基本状态" aria-hidden="true">#</a></h1><pre><code>- RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。
- SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。
- STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。
- TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。
- TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。
</code></pre><blockquote><p>线程池状态的转移有两个路径：</p></blockquote><pre><code> - 当调用 shutdown() 方法时，线程池的状态会从 RUNNING 到 SHUTDOWN，再到 TIDYING，最后到 TERMENATED 销毁状态；
 - 当调用 shutdownNow() 方法时，线程池的状态会从 RUNNING 到 STOP，再到 TIDYING，最后到 TERMENATED 销毁状态。

 ---
</code></pre><h1 id="_2-抛出以下几个问题-如果都能回答上来-这个文章也就不用看了。。" tabindex="-1">2.抛出以下几个问题，如果都能回答上来，这个文章也就不用看了。。 <a class="header-anchor" href="#_2-抛出以下几个问题-如果都能回答上来-这个文章也就不用看了。。" aria-hidden="true">#</a></h1><ul><li>面试官：日常工作中有用到线程池吗？什么是线程池？为什么要使用线程池？</li><li>面试官：ThreadPoolExecutor 都有哪些核心参数？</li><li>面试官：你刚也说到了 Worker 继承 AQS 实现了锁机制，那 ThreadPoolExecutor 都用到了哪些锁？为什么要用锁？</li><li>面试官：你在项目中是怎样使用线程池的？Executors 了解吗？</li><li>面试官：刚你说到了通过 ThreadPoolExecutor 来创建线程池，那核心参数设置多少合适呢？</li><li>面试官：你们线程池是咋监控的？</li><li>面试官：execute() 提交任务和 submit() 提交任务有啥不同？</li><li>面试官：什么是阻塞队列？阻塞队列有哪些？</li><li>面试官：线程池拒绝策略有哪些？适用场景是怎么样的？</li><li>面试官：你在使用线程池的过程中遇到过哪些坑或者需要注意的地方？</li></ul><hr><h1 id="_3-对上面的问题进行解答" tabindex="-1">3.对上面的问题进行解答 <a class="header-anchor" href="#_3-对上面的问题进行解答" aria-hidden="true">#</a></h1><h1 id="_1-面试官-日常工作中有用到线程池吗-什么是线程池-为什么要使用线程池" tabindex="-1">1.面试官：日常工作中有用到线程池吗？什么是线程池？为什么要使用线程池？ <a class="header-anchor" href="#_1-面试官-日常工作中有用到线程池吗-什么是线程池-为什么要使用线程池" aria-hidden="true">#</a></h1><blockquote><p>一般面试官考察你线程池相关知识前，大概率会先问这个问题，如果你说没用过，不了解，ok，那就没以下问题啥事了，估计你的面试结果肯定也凶多吉少了。 作为 JUC 包下的门面担当，线程池是名副其实的 JUC 一哥，不了解线程池，那说明你对 JUC 包其他工具也了解的不咋样吧，对 JUC 没深入研究过，那就是没掌握到 Java 的精髓，给面试官这样一个印象，那结果可想而知了。 所以说，这一分一定要吃下，那我们应该怎么回答好这问题呢？</p></blockquote><blockquote><p><strong>可以这样说：</strong> 计算机发展到现在，摩尔定律在现有工艺水平下已经遇到难易突破的物理瓶颈，通过多核 CPU 并行计算来提升服务器的性能已经成为主流，随之出现了多线程技术。 线程作为操作系统宝贵的资源，对它的使用需要进行控制管理，线程池就是采用池化思想（类似连接池、常量池、对象池等）管理线程的工具。 JUC 给我们提供了 ThreadPoolExecutor 体系类来帮助我们更方便的管理线程、并行执行任务。 顶级接口Executor提供了一种方式，解耦任务的提交和执行，只定义了一个 execute(Runnable command) 方法用来提交任务，至于具体任务怎么执行则交给他的实现者去自定义实现。 ExecutorService 接口继承 Executor，且扩展了生命周期管理的方法、返回 Futrue 的方法、批量提交任务的方法。 AbstractExecutorService 抽象类继承 ExecutorService 接口，对 ExecutorService 相关方法提供了默认实现，用 RunnableFuture 的实现类 FutureTask 包装 Runnable 任务，交给 execute() 方法执行，然后可以从该 FutureTask 阻塞获取执行结果，并且对批量任务的提交做了编排。 ThreadPoolExecutor 继承 AbstractExecutorService，采用池化思想管理一定数量的线程来调度执行提交的任务，且定义了一套线程池的生命周期状态，用一个 ctl 变量来同时保存当前池状态（高3位）和当前池线程数（低29位）。看过源码的小伙伴会发现，ThreadPoolExecutor 类里的方法大量有同时需要获取或更新池状态和池当前线程数的场景，放一个原子变量里，可以很好的保证数据的一致性以及代码的简洁性，说到 ctl 了，可以顺便讲下几个状态之间的流转过程。</p></blockquote><blockquote><p><strong>使用线程池可以带来以下好处：</strong> - 降低资源消耗。降低频繁创建、销毁线程带来的额外开销，复用已创建线程 - 降低使用复杂度。将任务的提交和执行进行解耦，我们只需要创建一个线程池，然后往里面提交任务就行，具体执行流程由<br> - 线程池自己管理，降低使用复杂度 - 提高线程可管理性。能安全有效的管理线程资源，避免不加限制无限申请造成资源耗尽风险 - 提高响应速度。任务到达后，直接复用已创建好的线程执行</p></blockquote><blockquote><p><strong>线程池的使用场景简单来说可以有：</strong> - 快速响应用户请求，响应速度优先。比如一个用户请求，需要通过 RPC 调用好几个服务去获取数据然后聚合返回，此场景就可以用线程池并行调用，响应时间取决于响应最慢的那个 RPC 接口的耗时； - 又或者一个注册请求，注册完之后要发送短信、邮件通知，为了快速返回给用户，可以将该通知操作丢到线程池里异步去执行，然后直接返回客户端成功，提高用户体验。 - 单位时间处理更多请求，吞吐量优先。比如接受 MQ 消息，然后去调用第三方接口查询数据，此场景并不追求快速响应，主要利用有限的资源在单位时间内尽可能多的处理任务，可以利用队列进行任务的缓冲。 - 基于以上使用场景，可以套到自己项目中，说下为了提升系统性能，自己对负责的系统模块使用线程池做了哪些优化，优化前后对比 Qps 提升多少、Rt 降低多少、服务器数量减少多少等等。</p></blockquote><ul><li>2.面试官：ThreadPoolExecutor 都有哪些核心参数？</li></ul><blockquote><p>其实一般面试官问你这个问题并不是简单听你说那几个参数，更多的是想听你描述下线程池执行流程。</p></blockquote><blockquote><p><strong>青铜回答：</strong> 包含核心线程数（corePoolSize）、最大线程数（maximumPoolSize），空闲线程超时时间（keepAliveTime）、时间单位（unit）、阻塞队列（workQueue）、拒绝策略（handler）、线程工厂（ThreadFactory）这7个参数。 这个回答基本上也没毛病，但只能 60 分飘过。</p></blockquote><blockquote><p><strong>钻石回答：</strong> 回答完包含这几个参数之后，会再主动描述下线程池的执行流程，也就是 execute() 方法执行流程。 execute()方法执行逻辑如下：</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">execute</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Runnable</span><span style="color:#A6ACCD;"> command</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NullPointerException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ctl</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">workerCountOf</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> corePoolSize</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">addWorker</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true))</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ctl</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">isRunning</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">c</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> workQueue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> recheck </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ctl</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">isRunning</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">recheck</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">remove</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#82AAFF;">reject</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">workerCountOf</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">recheck</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#82AAFF;">addWorker</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#82AAFF;">addWorker</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false))</span></span>
<span class="line"><span style="color:#82AAFF;">reject</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">command</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>可以总结出如下主要执行流程，当然看上述代码会有一些异常分支判断，可以自己梳理加到下述执行主流程里</p></blockquote><ul><li>判断线程池的状态，如果不是RUNNING状态，直接执行拒绝策略</li><li>如果当前线程数 &lt; 核心线程池，则新建一个线程来处理提交的任务</li><li>如果当前线程数 &gt; 核心线程数且任务队列没满，则将任务放入阻塞队列等待执行</li><li>如果 核心线程池 &lt; 当前线程池数 &lt; 最大线程数，且任务队列已满，则创建新的线程执行提交的任务</li><li>如果当前线程数 &gt; 最大线程数，且队列已满，则执行拒绝策略拒绝该任务</li></ul><blockquote><p>这个回答就比较能体现出你的悟性，能主动描述线程池执行流程，说明你对线程池还是比较了解的，在面试官心里就会留下还行的印象，这也是你要面高级 Java 必须要达到的最低要求，这个回答拿个 75 分应该问题不大。</p></blockquote><blockquote><p><strong>王者回答：</strong> 在回答完包含哪些参数及 execute 方法的执行流程后。然后可以说下这个执行流程是 JUC 标准线程池提供的执行流程，主要用在 CPU 密集型场景下。 像 Tomcat、Dubbo 这类框架，他们内部的线程池主要用来处理网络 IO 任务的，所以他们都对 JUC 线程池的执行流程进行了调整来支持 IO 密集型场景使用。 他们提供了阻塞队列 TaskQueue，该队列继承 LinkedBlockingQueue，重写了 offer() 方法来实现执行流程的调整。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Runnable</span><span style="color:#A6ACCD;"> o</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//we can&#39;t do any checks</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">==null)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//we are maxed out on threads, simply queue the object</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPoolSize</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMaximumPoolSize</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//we have idle threads, just add it to the queue</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getSubmittedCount</span><span style="color:#89DDFF;">()&lt;=(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPoolSize</span><span style="color:#89DDFF;">()))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//if we have less threads than maximum force creation of a new thread</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPoolSize</span><span style="color:#89DDFF;">()&lt;</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getMaximumPoolSize</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//if we reached here, we need to add it to the queue</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> super</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">offer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>可以看到他在入队之前做了几个判断，这里的 parent 就是所属的线程池对象</p></blockquote><ul><li>1.如果 parent 为 null，直接调用父类 offer 方法入队</li><li>2.如果当前线程数等于最大线程数，则直接调用父类 offer()方法入队</li><li>3.如果当前未执行的任务数量小于等于当前线程数，仔细思考下，是不是说明有空闲的线程呢，那么直接调用父类 offer() 入队后就马上有线程去执行它</li><li>4.如果当前线程数小于最大线程数量，则直接返回 false，然后回到 JUC 线程池的执行流程回想下，是不是就去添加新线程去执行任务了呢</li><li>5.其他情况都直接入队</li></ul><hr><h1 id="_3-面试官-你刚也说到了-worker-继承-aqs-实现了锁机制-那-threadpoolexecutor-都用到了哪些锁-为什么要用锁" tabindex="-1">3. 面试官：你刚也说到了 Worker 继承 AQS 实现了锁机制，那 ThreadPoolExecutor 都用到了哪些锁？为什么要用锁？ <a class="header-anchor" href="#_3-面试官-你刚也说到了-worker-继承-aqs-实现了锁机制-那-threadpoolexecutor-都用到了哪些锁-为什么要用锁" aria-hidden="true">#</a></h1><blockquote><p>这个问题比较刁钻，一般准备过程中可能不太会注意，那下面我们来一起看下用到了那些锁。</p></blockquote><ul><li>mainLock 锁</li></ul><blockquote><p>ThreadPoolExecutor 内部维护了 ReentrantLock 类型锁 mainLock，在访问 workers 成员变量以及进行相关数据统计记账（比如访问 largestPoolSize、completedTaskCount）时需要获取该重入锁。 面试官：为什么要有 mainLock？</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ReentrantLock</span><span style="color:#A6ACCD;"> mainLock </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ReentrantLock</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* Set containing all worker threads in pool. Accessed only when</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* holding mainLock.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashSet</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Worker</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> workers </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">HashSet</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">Worker</span><span style="color:#89DDFF;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* Tracks largest attained pool size. Accessed only under</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* mainLock.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> largestPoolSize</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* Counter for completed tasks. Updated only on termination of</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* worker threads. Accessed only under mainLock.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> completedTaskCount</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote></blockquote><p>可以看到 workers 变量用的 HashSet 是线程不安全的，是不能用于多线程环境的。largestPoolSize、completedTaskCount 也是没用 volatile 修饰，所以需要在锁的保护下进行访问。 面试官：为什么不直接用个线程安全容器呢？ 其实 Doug 老爷子在 mainLock 变量的注释上解释了，意思就是说事实证明，相比于线程安全容器，此处更适合用 lock，主要原因之一就是串行化 interruptIdleWorkers() 方法，避免了不必要的中断风暴。 面试官：怎么理解这个中断风暴呢？ 其实简单理解就是如果不加锁，interruptIdleWorkers() 方法在多线程访问下就会发生这种情况。一个线程调用interruptIdleWorkers() 方法对 Worker 进行中断，此时该 Worker 出于中断中状态，此时又来一个线程去中断正在中断中的 Worker 线程，这就是所谓的中断风暴。 面试官：那 largestPoolSize、completedTaskCount 变量加个 volatile 关键字修饰是不是就可以不用 mainLock 了？ 这个其实 Doug 老爷子也考虑到了，其他一些内部变量能用 volatile 的都加了 volatile 修饰了，这两个没加主要就是为了保证这两个参数的准确性，在获取这两个值时，能保证获取到的一定是修改方法执行完成后的值。如果不加锁，可能在修改方法还没执行完成时，此时来获取该值，获取到的就是修改前的值，然后修改方法一提交，就会造成获取到的数据不准确了。</p><ul><li>2）Worker 线程锁</li></ul><blockquote><p>刚也说了 Worker 线程继承 AQS，实现了 Runnable 接口，内部持有一个 Thread 变量，一个 firstTask，及 completedTasks 三个成员变量。 基于 AQS 的 acquire()、tryAcquire() 实现了 lock()、tryLock() 方法，类上也有注释，该锁主要是用来维护运行中线程的中断状态。在 runWorker() 方法中以及刚说的 interruptIdleWorkers() 方法中用到了。 面试官：这个维护运行中线程的中断状态怎么理解呢？</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryAcquire</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> unused</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">compareAndSetState</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#82AAFF;">setExclusiveOwnerThread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">currentThread</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lock</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">acquire</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryLock</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryAcquire</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>在runWorker() 方法中获取到任务开始执行前，需要先调用 w.lock() 方法，lock() 方法会调用 tryAcquire() 方法，tryAcquire() 实现了一把非重入锁，通过 CAS 实现加锁</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">tryAcquire</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> unused</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">compareAndSetState</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#82AAFF;">setExclusiveOwnerThread</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">Thread</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">currentThread</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>interruptIdleWorkers() 方法会中断那些等待获取任务的线程，会调用 w.tryLock() 方法来加锁，如果一个线程已经在执行任务中，那么 tryLock() 就获取锁失败，就保证了不能中断运行中的线程了。</p></blockquote><hr><h1 id="_4-面试官-你在项目中是怎样使用线程池的-executors-了解吗" tabindex="-1">4. 面试官：你在项目中是怎样使用线程池的？Executors 了解吗？ <a class="header-anchor" href="#_4-面试官-你在项目中是怎样使用线程池的-executors-了解吗" aria-hidden="true">#</a></h1><blockquote></blockquote><ul><li>这里面试官主要想知道你日常工作中使用线程池的姿势，现在大多数公司都在遵循阿里巴巴 Java 开发规范，该规范里明确说明不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 显示指定参数去创建。</li><li>你可以这样说，知道 Executors 工具类，很久之前有用过，也踩过坑，Executors 创建的线程池有发生 OOM 的风险。</li><li>Executors.newFixedThreadPool 和 Executors.SingleThreadPool 创建的线程池内部使用的是无界（Integer.MAX_VALUE）的 LinkedBlockingQueue 队列，可能会堆积大量请求，导致 OOM。</li><li>Executors.newCachedThreadPool 和 Executors.scheduledThreadPool 创建的线程池最大线程数是用的Integer.MAX_VALUE，可能会创建大量线程，导致 OOM。</li><li>自己在日常工作中也有封装类似的工具类，但是都是内存安全的，参数需要自己指定适当的值，也有基于 LinkedBlockingQueue 实现了内存安全阻塞队列 MemorySafeLinkedBlockingQueue，当系统内存达到设置的最大剩余阈值时，就不在往队列里添加任务了，避免发生 OOM。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ThreadPoolExecutor</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newFixedThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> threadPrefix</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> poolSize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> queueCapacity</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> ThreadPoolBuilder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newBuilder</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">corePoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">poolSize</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">maximumPoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">poolSize</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">workQueue</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">QueueTypeEnum</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MEMORY_SAFE_LINKED_BLOCKING_QUEUE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queueCapacity</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">threadFactory</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">threadPrefix</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">buildDynamic</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ExecutorService</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newCachedThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> threadPrefix</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> maximumPoolSize</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> ThreadPoolBuilder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newBuilder</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">corePoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">maximumPoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">maximumPoolSize</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">workQueue</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">QueueTypeEnum</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SYNCHRONOUS_QUEUE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">threadFactory</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">threadPrefix</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">buildDynamic</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ThreadPoolExecutor</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newThreadPool</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> threadPrefix</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> corePoolSize</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> maximumPoolSize</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> queueCapacity</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> ThreadPoolBuilder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newBuilder</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">corePoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">corePoolSize</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">maximumPoolSize</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">maximumPoolSize</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">workQueue</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">QueueTypeEnum</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">MEMORY_SAFE_LINKED_BLOCKING_QUEUE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getName</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> queueCapacity</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">threadFactory</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">threadPrefix</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">buildDynamic</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><ul><li>我们一般都是在 Spring 环境中使用线程池的，直接使用 JUC 原生 ThreadPoolExecutor 有个问题，Spring 容器关闭的时候可能任务队列里的任务还没处理完，有丢失任务的风险。</li></ul></blockquote><ul><li>我们知道 Spring 中的 Bean 是有生命周期的，如果 Bean 实现了 Spring 相应的生命周期接口（InitializingBean、DisposableBean接口），在 Bean 初始化、容器关闭的时候会调用相应的方法来做相应处理。</li><li>所以最好不要直接使用 ThreadPoolExecutor 在 Spring 环境中，可以使用 Spring 提供的 ThreadPoolTaskExecutor，或者 DynamicTp 框架提供的 DtpExecutor 线程池实现。</li><li>也会按业务类型进行线程池隔离，各任务执行互不影响，避免共享一个线程池，任务执行参差不齐，相互影响，高耗时任务会占满线程池资源，导致低耗时任务没机会执行；同时如果任务之间存在父子关系，可能会导致死锁的发生，进而引发 OOM。</li><li>使用线程池的常规操作是通过 @Bean 定义多个业务隔离的线程池实例。我们是参考美团线程池实践那篇文章做了一个动态可监控线程池的轮子，而且利用了 Spring 的一些特性，将线程池实例都配置在配置中心里，服务启动的时候会从配置中心拉取配置然后生成 BeanDefination 注册到 Spring 容器中，在 Spring 容器刷新时会生成线程池实例注册到 Spring 容器中。这样我们业务代码就不用显式用 @Bean 声明线程池了，可以直接通过依赖注入的方式使用线程池，而且也可以动态调整线程池的参数了。</li></ul><hr><h1 id="_5-面试官-刚你说到了通过-threadpoolexecutor-来创建线程池-那核心参数设置多少合适呢" tabindex="-1">5. 面试官：刚你说到了通过 ThreadPoolExecutor 来创建线程池，那核心参数设置多少合适呢？ <a class="header-anchor" href="#_5-面试官-刚你说到了通过-threadpoolexecutor-来创建线程池-那核心参数设置多少合适呢" aria-hidden="true">#</a></h1><blockquote><p>这个问题该怎么回答呢？ 可能很多人都看到过《Java 并发编程实践》这本书里介绍的一个线程数计算公式： Ncpu = CPU 核数 Ucpu = 目标 CPU 利用率，0 &lt;= Ucpu &lt;= 1 W / C = 等待时间 / 计算时间 要程序跑到 CPU 的目标利用率，需要的线程数为： Nthreads = Ncpu * Ucpu * (1 + W / C)</p></blockquote><blockquote><p>这公式太偏理论化了，很难实际落地下来，首先很难获取准确的等待时间和计算时间。再着一个服务中会运行着很多线程，比如 Tomcat 有自己的线程池、Dubbo 有自己的线程池、GC 也有自己的后台线程，我们引入的各种框架、中间件都有可能有自己的工作线程，这些线程都会占用 CPU 资源，所以通过此公式计算出来的误差一定很大。 所以说怎么确定线程池大小呢？ 其实没有固定答案，需要通过压测不断的动态调整线程池参数，观察 CPU 利用率、系统负载、GC、内存、RT、吞吐量等各种综合指标数据，来找到一个相对比较合理的值。 所以不要再问设置多少线程合适了，这个问题没有标准答案，需要结合业务场景，设置一系列数据指标，排除可能的干扰因素，注意链路依赖（比如连接池限制、三方接口限流），然后通过不断动态调整线程数，测试找到一个相对合适的值。</p></blockquote><hr><h1 id="_7-面试官-execute-提交任务和-submit-提交任务有啥不同" tabindex="-1">7. 面试官：execute() 提交任务和 submit() 提交任务有啥不同？ <a class="header-anchor" href="#_7-面试官-execute-提交任务和-submit-提交任务有啥不同" aria-hidden="true">#</a></h1><blockquote><p>看到这个问题，是不是大多数人都觉得这个我行。execute() 无返回值，submit() 有返回值，会返回一个 FutureTask，然后可以调用 get() 方法阻塞获取返回值。 这样回答只能算及格，其实面试官问你这个问题主要想听你讲下 FutureTask 的实现原理，FutureTask 继承体系如下： 我们调用 submit() 方法提交的任务（Runnable or Callable）会被包装成 FutureTask() 对象。FutureTask 类提供了 7 种任务状态和五个成员变量。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">/*</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* Possible state transitions:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* NEW -&gt; COMPLETING -&gt; NORMAL</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* NEW -&gt; CANCELLED</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">* NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">*/</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 构造函数中 state 置为 NEW，初始态</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> NEW </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 瞬时态，表示完成中</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> COMPLETING </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 正常执行结束后的状态</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> NORMAL </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 异常执行结束后的状态</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> EXCEPTIONAL </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 调用 cancel 方法成功执行后的状态</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> CANCELLED </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 瞬时态，中断中</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> INTERRUPTING </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 正常执行中断后的状态</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> INTERRUPTED </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">6</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 任务状态，以上 7 种</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/** 通过 submit() 提交的任务，执行完后置为 null*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Callable</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">V</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> callable</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/** 任务执行结果或者调用 get() 要抛出的异常*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> outcome</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// non-volatile, protected by state reads/writes</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/** 执行任务的线程，会在 run() 方法中通过 cas 赋值*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> runner</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/** 调用get()后由等待线程组成的无锁并发栈，通过 cas 实现无锁*/</span></span>
<span class="line"><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">volatile</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">WaitNode</span><span style="color:#A6ACCD;"> waiters</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p>创建 FutureTask 对象时 state 置为 NEW，callable 赋值为我们传入的任务。 run() 方法中会去执行 callable 任务。执行之前先判断任务处于 NEW 状态并且通过 cas 设置 runner 为当前线程成功。然后去调用 call() 执行任务，执行成功后会调用 set() 方法将结果赋值给 outcome，任务执行抛出异常后会将异常信息调用 setException() 赋值给 outcome。至于为什么要先将状态变为 COMPLETING，再变为 NORMAL，主要是为了保证在 NORMAL 态时已经完成了 outcome 赋值。finishCompletion() 会去唤醒（通过 LockSupport.unpark()）那些因调用 get() 而阻塞的线程（waiters）。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">set</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">V</span><span style="color:#A6ACCD;"> v</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">UNSAFE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compareAndSwapInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> stateOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> NEW</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> COMPLETING</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">outcome </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> v</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">UNSAFE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">putOrderedInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> stateOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> NORMAL</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// final state</span></span>
<span class="line"><span style="color:#82AAFF;">finishCompletion</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>调用 get() 方法会阻塞获取结果（或异常），如果 state &gt; COMPLETING，说明任务已经执行完成（NORMAL、EXCEPTIONAL、CANCELLED、INTERRUPTED），则直接通过 report() 方法返回结果或抛出异常。如果state &lt;= COMPLETING，说明任务还在执行中或还没开始执行，则调用 awaitDone() 方法进行阻塞等待。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">V</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">long</span><span style="color:#A6ACCD;"> timeout</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">TimeUnit</span><span style="color:#A6ACCD;"> unit</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">throws InterruptedException</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ExecutionException</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> TimeoutException </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">unit </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NullPointerException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> s </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#A6ACCD;"> COMPLETING </span><span style="color:#89DDFF;">&amp;&amp;</span></span>
<span class="line"><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">awaitDone</span><span style="color:#89DDFF;">(true,</span><span style="color:#A6ACCD;"> unit</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toNanos</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">timeout</span><span style="color:#89DDFF;">)))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#A6ACCD;"> COMPLETING</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">TimeoutException</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">report</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">s</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>awaitDone() 方法则通过 state 状态判断来决定直接返回还是将当前线程添加到 waiters 里，然后调用LockSupport.park() 方法挂起当前线程。</p></blockquote><blockquote><p>还有个重要的 cancel() 方法，因为 FutureTask 源码类注释的第一句就说了 FutureTask 是一个可取消的异步计算。代码也非常简单，如果 state 不是 NEW 或者通过 CAS 赋值为 INTERRUPTING / CANCELLED 失败则直接返回。反之如果 mayInterruptIfRunning = ture，表示可能中断在运行中线程，则中断线程，state 变为 INTERRUPTED，最后去唤醒等待的线程。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cancel</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> mayInterruptIfRunning</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!(</span><span style="color:#A6ACCD;">state </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> NEW </span><span style="color:#89DDFF;">&amp;&amp;</span></span>
<span class="line"><span style="color:#A6ACCD;">UNSAFE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">compareAndSwapInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> stateOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> NEW</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">mayInterruptIfRunning </span><span style="color:#89DDFF;font-style:italic;">?</span><span style="color:#A6ACCD;"> INTERRUPTING </span><span style="color:#89DDFF;font-style:italic;">:</span><span style="color:#A6ACCD;"> CANCELLED</span><span style="color:#89DDFF;">)))</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">false;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// in case call to interrupt throws exception</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">mayInterruptIfRunning</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#C792EA;">Thread</span><span style="color:#A6ACCD;"> t </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> runner</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">t </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null)</span></span>
<span class="line"><span style="color:#A6ACCD;">t</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">interrupt</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// final state</span></span>
<span class="line"><span style="color:#A6ACCD;">UNSAFE</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">putOrderedInt</span><span style="color:#89DDFF;">(this,</span><span style="color:#A6ACCD;"> stateOffset</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> INTERRUPTED</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#82AAFF;">finishCompletion</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>以上简单介绍了下 FutureTask 的执行流程，篇幅有限，源码解读的不是很仔细，后面可以考虑单独出一篇文章好好分析下 FutureTask 的源码。</p></blockquote><hr><h1 id="_8-面试官-什么是阻塞队列-阻塞队列有哪些-阻塞队列-blockingqueue-继承-queue-是我们熟悉的基本数据结构队列的一种特殊类型。" tabindex="-1">8. 面试官：什么是阻塞队列？阻塞队列有哪些？阻塞队列 BlockingQueue 继承 Queue，是我们熟悉的基本数据结构队列的一种特殊类型。 <a class="header-anchor" href="#_8-面试官-什么是阻塞队列-阻塞队列有哪些-阻塞队列-blockingqueue-继承-queue-是我们熟悉的基本数据结构队列的一种特殊类型。" aria-hidden="true">#</a></h1><blockquote><p>当从阻塞队列中获取数据时，如果队列为空，则等待直到队列有元素存入。当向阻塞队列中存入元素时，如果队列已满，则等待直到队列中有元素被移除。提供 offer()、put()、take()、poll() 等常用方法。 JDK 提供的阻塞队列的实现有以下前 7 种：</p></blockquote><ul><li>1）ArrayBlockingQueue：由数组实现的有界阻塞队列，该队列按照 FIFO 对元素进行排序。维护两个整形变量，标识队列头尾在数组中的位置，在生产者放入和消费者获取数据共用一个锁对象，意味着两者无法真正的并行运行，性能较低。</li><li>2）LinkedBlockingQueue：由链表组成的有界阻塞队列，如果不指定大小，默认使用 Integer.MAX_VALUE 作为队列大小，该队列按照 FIFO 对元素进行排序，对生产者和消费者分别维护了独立的锁来控制数据同步，意味着该队列有着更高的并发性能。</li><li>3）SynchronousQueue：不存储元素的阻塞队列，无容量，可以设置公平或非公平模式，插入操作必须等待获取操作移除元素，反之亦然。</li><li>4）PriorityBlockingQueue：支持优先级排序的无界阻塞队列，默认情况下根据自然序排序，也可以指定 Comparator。</li><li>5）DelayQueue：支持延时获取元素的无界阻塞队列，创建元素时可以指定多久之后才能从队列中获取元素，常用于缓存系统或定时任务调度系统。</li><li>6）LinkedTransferQueue：一个由链表结构组成的无界阻塞队列，与LinkedBlockingQueue相比多了transfer和tryTranfer方法，该方法在有消费者等待接收元素时会立即将元素传递给消费者。</li><li>7）LinkedBlockingDeque：一个由链表结构组成的双端阻塞队列，可以从队列的两端插入和删除元素。</li><li>8）VariableLinkedBlockingQueue：说完以上 JDK 提供这几个阻塞队列后，还可以说下 LinkedBlockingQueue 是我们使用最广泛的阻塞队列，但是 LinkedBlockingQueue 一旦定义好后是不能修改容量 capacity 的。自己在使用线程池的过程中有动态去调整容量的需求，所以参考 RabbitMq 里的 VariableLinkedBlockingQueue，实现了一个可以调整容量的增强版 LinkedBlockingQueue，实现容量的动态调整。</li><li>9）MemorySafeLinkedBlockingQueue：而且 LinkedBlockingQueue 默认是使用 Integer.MAX_VALUE 作为容量的，也就是个无界队列，可能会有发生 OOM 的风险，所以自己实现了一个内存安全的 MemorySafeLinkedBlockingQueue，可以配置最大剩余内存，当内存达到该值的时候，再往队列放任务就会失败，很好的保证了不会发生令人头疼的 OOM 问题。</li><li>10）TaskQueue：上面讲 Tomcat 线程池时说过该阻塞队列，作为 LinkedBlockingQueue 的子类，覆写了 offer()、poll()、take() 等方法来调整线程池的执行流程。 重点说下 8、9 这两个自定义阻塞队列，来突出你对阻塞队列丰富的使用经验，这两队列源码可以看以下地址： MemorySafeLinkedBlockingQueue &amp; VariableLinkedBlockingQueue 队列实现</li></ul><hr><h1 id="_9-面试官-线程池拒绝策略有哪些-适用场景是怎么样的" tabindex="-1">9. 面试官：线程池拒绝策略有哪些？适用场景是怎么样的？ <a class="header-anchor" href="#_9-面试官-线程池拒绝策略有哪些-适用场景是怎么样的" aria-hidden="true">#</a></h1><blockquote><p>当阻塞队列已满并且达到最大线程数时，再提交任务会走拒绝策略流程，JDK 提供了拒绝策略顶层接口 RejectedExecutionHandler，所有拒绝策略都需要继承该接口，JDK 内置了四种拒绝策略。</p></blockquote><ul><li>1）AbortPolicy：线程池默认的拒绝策略，触发时会抛出 RejectedExecutionException 异常。如果是一些比较重要的业务，可以使用该拒绝策略，在系统不能进一步支持更大并发量的情况下通过抛出异常及时发现问题并进行处理。</li><li>2）CallerRunsPolicy：在线程池没关闭的情况下，由调用者线程去处理任务，反之直接丢弃。此拒绝策略追求任务都能被执行，不丢失，比较适合并发量不大并且不允许丢失任务的场景场景，性能较低。</li><li>3）DiscardPolicy：丢弃任务，不抛出异常，一般无感知。建议一些无关紧要的任务可以使用此策略。</li><li>4）DiscardOldestPolicy：丢弃队列中最老的任务，然后重新提交被拒绝的任务。需要根据业务场景进行选择是否要用。</li><li>3、4 这两种拒绝策略都在会在无感知的情况下丢弃任务，需要根据业务场景决定是否要使用。 也可以根据自己需要自定义拒绝策略，比如 Dubbo 定义了拒绝策略 AbortPolicyWithReport，在抛出异常前会先进行线程堆栈信息的打印。10. 面试官：你在使用线程池的过程中遇到过哪些坑或者需要注意的地方？ 这个问题其实也是在考察你对一些细节的掌握程度，就全甩锅给年轻刚毕业没经验的自己就行。可以适当多说些，也证明自己对线程池有着丰富的使用经验。</li><li>1）OOM 问题。刚开始使用线程都是通过 Executors 创建的，前面说了，这种方式创建的线程池会有发生 OOM 的风险，可以举例说明。</li><li>2）任务执行异常丢失问题。可以通过下述4种方式解决</li></ul><blockquote><p>在任务代码中增加 try、catch 异常处理 如果使用的 Future 方式，则可通过 Future 对象的 get 方法接收抛出的异常</p></blockquote><blockquote><p><strong>为工作线程设置</strong> setUncaughtExceptionHandler，在 uncaughtException 方法中处理异常 可以重写 afterExecute(Runnable r, Throwable t) 方法，拿到异常 t</p></blockquote><ul><li>3）共享线程池问题。整个服务共享一个全局线程池，导致任务相互影响，耗时长的任务占满资源，短耗时任务得不到执行。同时父子线程间会导致死锁的发生，进而导致 OOM。</li><li>4）跟 ThreadLocal 配合使用，导致脏数据问题。我们知道 Tomcat 利用线程池来处理收到的请求，会复用线程，如果我们代码中用到了 ThreadLocal，在请求处理完后没有去 remove，那每个请求就有可能获取到之前请求遗留的脏值。</li><li>5）ThreadLocal 在线程池场景下会失效，可以考虑用阿里开源的 Ttl 来解决。</li><li>6）需要自定义线程工厂指定线程名称，不然发生问题都不知道咋定位。 以上提到的线程池动态调参、通知告警在开源动态线程池项目 DynamicTp 中已经实现了，可以直接引入到自己项目中使用。</li></ul><hr>`,78);function r(D,y,F,i,A,C){const s=e("Comment");return p(),a("div",null,[c,l(s)])}const E=n(t,[["render",r]]);export{d as __pageData,E as default};
